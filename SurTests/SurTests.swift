//
//  SurTests.swift
//  SurTests
//
//  Created by Mathe Eliel on 04/10/2025.
//

import Testing
import Foundation
@testable import Sur

struct SurTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}

// MARK: - Ethereum Key Generation Tests (MetaMask Compatibility)

struct EthereumKeyManagerTests {
    
    /// Test vector: Well-known mnemonic phrase used for testing Ethereum wallets
    /// This mnemonic generates specific addresses that can be verified against MetaMask
    ///
    /// The BIP-39 test mnemonic from https://iancoleman.io/bip39/
    /// Mnemonic: "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
    /// Expected Ethereum address at m/44'/60'/0'/0/0: 0x9858EfFD232B4033E47d90003D41EC34EcaEda94
    ///
    /// Note: This is a well-known test vector - NEVER use this mnemonic for real funds
    
    @Test func testMetaMaskCompatibleAddressGeneration() async throws {
        // Well-known BIP-39 test mnemonic
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        // Generate keys and address
        let result = try EthereumKeyManager.generateKeysFromMnemonic(testMnemonic)
        
        // The expected address from MetaMask/BIP-44 standard for this mnemonic at m/44'/60'/0'/0/0
        // This address is generated by MetaMask and other standard wallets for this exact mnemonic
        let expectedAddress = "0x9858EfFD232B4033E47d90003D41EC34EcaEda94"
        
        // Verify the address matches MetaMask
        #expect(result.address.lowercased() == expectedAddress.lowercased(),
                "Generated address should match MetaMask for the same mnemonic")
        
        // Verify the private key length
        #expect(result.privateKey.count == 32, "Private key should be 32 bytes")
    }
    
    @Test func testEIP55ChecksumAddress() async throws {
        // Test EIP-55 checksum implementation
        // Example: 0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359 should become
        // 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359
        
        let lowercaseAddress = "fb6916095ca1df60bb79ce92ce3ea74c37c5d359"
        let checksummed = EthereumKeyManager.checksumAddress(lowercaseAddress)
        
        // Verify it starts with 0x
        #expect(checksummed.hasPrefix("0x"), "Checksummed address should start with 0x")
        
        // Verify it has the correct length
        #expect(checksummed.count == 42, "Checksummed address should be 42 characters (0x + 40 hex)")
    }
    
    @Test func testPrivateKeyDerivation() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        // Convert mnemonic to seed
        let seed = try MnemonicGenerator.mnemonicToSeed(testMnemonic)
        
        // Verify seed length (64 bytes as per BIP-39)
        #expect(seed.count == 64, "BIP-39 seed should be 64 bytes")
        
        // Derive private key
        let privateKey = try EthereumKeyManager.derivePrivateKey(from: seed)
        
        // Verify private key length
        #expect(privateKey.count == 32, "Private key should be 32 bytes")
        
        // Verify private key is not all zeros
        let isZero = privateKey.allSatisfy { $0 == 0 }
        #expect(!isZero, "Private key should not be all zeros")
    }
    
    @Test func testAddressShortening() async throws {
        let fullAddress = "0x9858EfFD232B4033E47d90003D41EC34EcaEda94"
        let shortened = EthereumKeyManager.shortenAddress(fullAddress)
        
        // Verify shortened format
        #expect(shortened == "0x9858...da94", "Shortened address should show first 6 and last 4 characters")
    }
    
    @Test func testMultipleAccountIndices() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        // Generate addresses for first 3 accounts
        let address0 = try EthereumKeyManager.generateKeysFromMnemonic(testMnemonic, accountIndex: 0).address
        let address1 = try EthereumKeyManager.generateKeysFromMnemonic(testMnemonic, accountIndex: 1).address
        let address2 = try EthereumKeyManager.generateKeysFromMnemonic(testMnemonic, accountIndex: 2).address
        
        // All addresses should be different
        #expect(address0 != address1, "Different account indices should produce different addresses")
        #expect(address1 != address2, "Different account indices should produce different addresses")
        #expect(address0 != address2, "Different account indices should produce different addresses")
    }
}

// MARK: - MultiChain Key Manager Tests

struct MultiChainKeyManagerTests {
    
    @Test func testEthereumAddressGeneration() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let result = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .ethereum)
        
        // Expected address from MetaMask for this mnemonic
        let expectedAddress = "0x9858EfFD232B4033E47d90003D41EC34EcaEda94"
        
        #expect(result.address.lowercased() == expectedAddress.lowercased(),
                "MultiChainKeyManager Ethereum address should match MetaMask")
    }
    
    @Test func testBSCAddressMatchesEthereum() async throws {
        // BSC (Binance Smart Chain) uses the same derivation path as Ethereum
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let ethResult = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .ethereum)
        let bscResult = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .bsc)
        
        #expect(ethResult.address == bscResult.address,
                "BSC address should match Ethereum address (same derivation path)")
    }
    
    @Test func testOriginTrailAddressMatchesEthereum() async throws {
        // OriginTrail (TRAC) is an ERC-20 token, uses same derivation as Ethereum
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let ethResult = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .ethereum)
        let tracResult = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .originTrail)
        
        #expect(ethResult.address == tracResult.address,
                "OriginTrail address should match Ethereum address (ERC-20 token)")
    }
    
    @Test func testTronAddressFormat() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let result = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .tron)
        
        // Tron addresses should start with 'T'
        #expect(result.address.hasPrefix("T"), "Tron address should start with 'T'")
        
        // Tron addresses should be base58 encoded (no 0, O, I, l characters)
        let invalidChars = CharacterSet(charactersIn: "0OIl")
        let hasInvalidChars = result.address.unicodeScalars.contains { invalidChars.contains($0) }
        #expect(!hasInvalidChars, "Tron address should be valid base58 (no 0, O, I, l)")
    }
    
    @Test func testCosmosAddressFormat() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let result = try MultiChainKeyManager.generateKeysForNetwork(testMnemonic, network: .cosmos)
        
        // Cosmos addresses should start with 'cosmos1'
        #expect(result.address.hasPrefix("cosmos"), "Cosmos address should start with 'cosmos'")
    }
    
    @Test func testAllNetworksGenerateUniqueAddresses() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let addresses = try MultiChainKeyManager.generateAllAddresses(from: testMnemonic)
        
        // Count unique addresses (excluding networks that share derivation paths)
        // Ethereum, BSC, and OriginTrail share the same path
        let uniqueAddresses = Set(addresses.values)
        
        // At minimum, we should have different addresses for:
        // - Ethereum/BSC/OriginTrail (shared)
        // - Bitcoin
        // - Tron
        // - Cosmos
        // - Solana
        // That's at least 5 unique addresses
        #expect(uniqueAddresses.count >= 3, "Should have at least 3 unique addresses across different networks")
    }
}

// MARK: - Mnemonic Generator Tests

struct MnemonicGeneratorTests {
    
    @Test func testMnemonicValidation() async throws {
        let validMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        #expect(MnemonicGenerator.validateMnemonic(validMnemonic), "Test vector mnemonic should be valid")
    }
    
    @Test func testInvalidMnemonicRejection() async throws {
        let invalidMnemonic = "invalid word list that is not valid bip39"
        
        #expect(!MnemonicGenerator.validateMnemonic(invalidMnemonic), "Invalid mnemonic should be rejected")
    }
    
    @Test func testMnemonicGeneration() async throws {
        let mnemonic = try MnemonicGenerator.generateMnemonic(wordCount: 12)
        let words = mnemonic.split(separator: " ")
        
        #expect(words.count == 12, "Generated mnemonic should have 12 words")
        #expect(MnemonicGenerator.validateMnemonic(mnemonic), "Generated mnemonic should be valid")
    }
    
    @Test func testMnemonicToSeed() async throws {
        let testMnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        
        let seed = try MnemonicGenerator.mnemonicToSeed(testMnemonic)
        
        #expect(seed.count == 64, "BIP-39 seed should be 64 bytes")
        
        // The seed for this specific mnemonic should be deterministic
        // Expected seed (first 8 bytes) for verification
        let expectedFirstBytes: [UInt8] = [0x5e, 0xb0, 0x0b, 0xbd, 0xdc, 0xf0, 0x69, 0x08]
        let actualFirstBytes = Array(seed.prefix(8))
        
        #expect(actualFirstBytes == expectedFirstBytes, 
                "Seed should match expected BIP-39 derivation for this mnemonic")
    }
}
