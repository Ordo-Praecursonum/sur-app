//
//  EthereumKeyManager.swift
//  Sur
//
//  Manages Ethereum key derivation and address generation using proper cryptographic
//  primitives for MetaMask compatibility.
//
//  This implementation uses:
//  - secp256k1 curve for key generation (via web3.swift)
//  - Keccak-256 hashing for address derivation (via web3.swift)
//  - BIP-44 derivation path m/44'/60'/0'/0/{index}
//
//  These ensure addresses match those generated by MetaMask for the same mnemonic/seed.
//

import Foundation
import CryptoKit
import web3

/// Error types for Ethereum key operations
enum EthereumKeyError: LocalizedError {
    case invalidSeed
    case derivationFailed
    case invalidPrivateKey
    case invalidPublicKey
    case addressGenerationFailed
    
    var errorDescription: String? {
        switch self {
        case .invalidSeed:
            return "Invalid seed data for key derivation"
        case .derivationFailed:
            return "Failed to derive key"
        case .invalidPrivateKey:
            return "Invalid private key"
        case .invalidPublicKey:
            return "Invalid public key"
        case .addressGenerationFailed:
            return "Failed to generate Ethereum address"
        }
    }
}

/// Manages Ethereum key derivation following BIP-32/BIP-44 standards
///
/// This implementation uses the secp256k1 curve and Keccak-256 hashing via the web3.swift
/// library to ensure compatibility with MetaMask and other standard Ethereum wallets.
///
/// Key differences from test/demo implementations:
/// - Uses secp256k1 curve (not P256/NIST P-256) for key generation
/// - Uses Keccak-256 (not SHA256) for address derivation
/// - Implements full BIP-32 hierarchical deterministic key derivation
final class EthereumKeyManager {
    
    // MARK: - Constants
    
    /// BIP-44 derivation path for Ethereum: m/44'/60'/0'/0/0
    private static let ethereumDerivationPath = "m/44'/60'/0'/0/0"
    
    /// Hardened key offset (2^31)
    private static let hardenedOffset: UInt32 = 0x80000000
    
    /// secp256k1 curve order (n)
    private static let curveOrder: [UInt8] = [
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
        0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
        0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41
    ]
    
    // MARK: - Public Methods
    
    /// Derive private key from mnemonic seed using BIP-44 path m/44'/60'/0'/0/0
    /// - Parameters:
    ///   - seed: 64-byte seed from mnemonic
    ///   - accountIndex: Account index (default 0), used in path m/44'/60'/0'/0/{index}
    /// - Returns: 32-byte private key
    static func derivePrivateKey(from seed: Data, accountIndex: UInt32 = 0) throws -> Data {
        guard seed.count == 64 else {
            throw EthereumKeyError.invalidSeed
        }
        
        // Create master key from seed using HMAC-SHA512 (BIP-32)
        let masterKey = try deriveMasterKey(from: seed)
        
        // BIP-44 path for Ethereum: m/44'/60'/0'/0/{index}
        let path: [UInt32] = [
            44 + hardenedOffset,      // purpose (hardened)
            60 + hardenedOffset,      // coin_type for Ethereum (hardened)
            0 + hardenedOffset,       // account (hardened)
            0,                         // change (external)
            accountIndex               // address_index
        ]
        
        // Derive child key following BIP-44 path
        let derivedKey = try deriveKeyAtPath(
            masterPrivateKey: masterKey.privateKey,
            masterChainCode: masterKey.chainCode,
            path: path
        )
        
        return derivedKey.privateKey
    }
    
    /// Generate Ethereum public address from private key using secp256k1 and Keccak-256
    ///
    /// This method uses the web3.swift library for proper secp256k1 curve operations
    /// and Keccak-256 hashing, ensuring MetaMask compatibility.
    ///
    /// - Parameter privateKey: 32-byte private key
    /// - Returns: Ethereum address string (with 0x prefix, EIP-55 checksummed)
    static func generateAddress(from privateKey: Data) throws -> String {
        guard privateKey.count == 32 else {
            throw EthereumKeyError.invalidPrivateKey
        }
        
        // Generate public key using secp256k1 via web3.swift
        let publicKey = try generateSecp256k1PublicKey(from: privateKey)
        
        // Generate address using Keccak-256 via web3.swift
        let address = try generateAddressFromPublicKey(publicKey)
        
        return address
    }
    
    /// Generate both keys and address from mnemonic
    /// - Parameters:
    ///   - mnemonic: BIP-39 mnemonic phrase
    ///   - accountIndex: Account index (default 0)
    /// - Returns: Tuple of (privateKey, publicAddress)
    static func generateKeysFromMnemonic(_ mnemonic: String, accountIndex: UInt32 = 0) throws -> (privateKey: Data, address: String) {
        // Convert mnemonic to seed
        let seed = try MnemonicGenerator.mnemonicToSeed(mnemonic)
        
        // Derive private key using BIP-44 path
        let privateKey = try derivePrivateKey(from: seed, accountIndex: accountIndex)
        
        // Generate address using secp256k1 and Keccak-256
        let address = try generateAddress(from: privateKey)
        
        return (privateKey, address)
    }
    
    /// Format Ethereum address with EIP-55 checksum using Keccak-256
    ///
    /// - Parameter address: Lowercase address (with or without 0x prefix)
    /// - Returns: Checksummed address with 0x prefix
    static func checksumAddress(_ address: String) -> String {
        let cleanAddress = address.lowercased().hasPrefix("0x")
            ? String(address.dropFirst(2)).lowercased()
            : address.lowercased()
        
        // Hash the address using Keccak-256 (EIP-55 standard)
        guard let addressData = cleanAddress.data(using: .utf8) else {
            return "0x" + cleanAddress
        }
        let hash = addressData.web3.keccak256
        let hashHexString = String(hash.web3.hexString.dropFirst(2)) // Remove 0x prefix
        let hashHexArray = Array(hashHexString)
        
        // Apply checksum based on hash
        var checksummed = "0x"
        for (index, char) in cleanAddress.enumerated() {
            if char.isLetter {
                guard index < hashHexArray.count else { continue }
                let hashChar = hashHexArray[index]
                if let hashValue = Int(String(hashChar), radix: 16), hashValue >= 8 {
                    checksummed.append(char.uppercased())
                } else {
                    checksummed.append(char)
                }
            } else {
                checksummed.append(char)
            }
        }
        
        return checksummed
    }
    
    /// Shorten address for display (e.g., "0x1234...5678")
    /// - Parameter address: Full Ethereum address
    /// - Returns: Shortened address string
    static func shortenAddress(_ address: String) -> String {
        guard address.count >= 10 else { return address }
        let prefix = String(address.prefix(6))
        let suffix = String(address.suffix(4))
        return "\(prefix)...\(suffix)"
    }
    
    // MARK: - Private Methods - BIP-32 Key Derivation
    
    /// Derive master key from seed using HMAC-SHA512 (BIP-32 standard)
    private static func deriveMasterKey(from seed: Data) throws -> (privateKey: Data, chainCode: Data) {
        // Use "Bitcoin seed" as the key for HMAC (BIP-32 standard, also used for Ethereum)
        let key = "Bitcoin seed".data(using: .utf8)!
        
        // HMAC-SHA512
        let hmac = HMAC<SHA512>.authenticationCode(for: seed, using: SymmetricKey(data: key))
        let hmacData = Data(hmac)
        
        // First 32 bytes are the private key
        let privateKey = Data(hmacData.prefix(32))
        
        // Last 32 bytes are the chain code
        let chainCode = Data(hmacData.suffix(32))
        
        // Validate private key (must be less than curve order and non-zero)
        guard isValidPrivateKey(privateKey) else {
            throw EthereumKeyError.derivationFailed
        }
        
        return (privateKey, chainCode)
    }
    
    /// Derive child key at a given BIP-32/BIP-44 path
    private static func deriveKeyAtPath(
        masterPrivateKey: Data,
        masterChainCode: Data,
        path: [UInt32]
    ) throws -> (privateKey: Data, chainCode: Data) {
        var currentKey = masterPrivateKey
        var currentChainCode = masterChainCode
        
        for index in path {
            let isHardened = index >= hardenedOffset
            
            let (childKey, childChainCode) = try deriveChildKey(
                parentPrivateKey: currentKey,
                parentChainCode: currentChainCode,
                index: index,
                hardened: isHardened
            )
            
            currentKey = childKey
            currentChainCode = childChainCode
        }
        
        return (currentKey, currentChainCode)
    }
    
    /// Derive a single child key (BIP-32)
    private static func deriveChildKey(
        parentPrivateKey: Data,
        parentChainCode: Data,
        index: UInt32,
        hardened: Bool
    ) throws -> (privateKey: Data, chainCode: Data) {
        var data = Data()
        
        if hardened {
            // Hardened child: 0x00 || parent_private_key || index
            data.append(0x00)
            data.append(parentPrivateKey)
        } else {
            // Normal child: parent_compressed_public_key || index
            // Generate compressed public key using secp256k1
            let publicKey = try generateCompressedSecp256k1PublicKey(from: parentPrivateKey)
            data.append(publicKey)
        }
        
        // Append index as big-endian 4 bytes
        var indexBE = index.bigEndian
        data.append(Data(bytes: &indexBE, count: 4))
        
        // HMAC-SHA512
        let hmac = HMAC<SHA512>.authenticationCode(
            for: data,
            using: SymmetricKey(data: parentChainCode)
        )
        let hmacData = Data(hmac)
        
        // First 32 bytes for key derivation
        let keyData = Data(hmacData.prefix(32))
        
        // Last 32 bytes are the new chain code
        let childChainCode = Data(hmacData.suffix(32))
        
        // Add parent key to derived key (mod n for secp256k1)
        let childKey = try addPrivateKeys(parentPrivateKey, keyData)
        
        guard isValidPrivateKey(childKey) else {
            throw EthereumKeyError.derivationFailed
        }
        
        return (childKey, childChainCode)
    }
    
    /// Add two private keys together (mod secp256k1 curve order)
    private static func addPrivateKeys(_ key1: Data, _ key2: Data) throws -> Data {
        guard key1.count == 32 && key2.count == 32 else {
            throw EthereumKeyError.invalidPrivateKey
        }
        
        // Convert to big integers and add with carry, then mod by curve order
        var result = [UInt8](repeating: 0, count: 32)
        var carry: UInt16 = 0
        
        let bytes1 = [UInt8](key1)
        let bytes2 = [UInt8](key2)
        
        // Add bytes from right to left
        for i in (0..<32).reversed() {
            let sum = UInt16(bytes1[i]) + UInt16(bytes2[i]) + carry
            result[i] = UInt8(sum & 0xFF)
            carry = sum >> 8
        }
        
        // Reduce modulo curve order if needed
        var resultData = Data(result)
        if compareWithCurveOrder(resultData) >= 0 {
            resultData = subtractCurveOrder(from: resultData)
        }
        
        return resultData
    }
    
    /// Compare data with secp256k1 curve order
    /// Returns: -1 if data < order, 0 if equal, 1 if data > order
    private static func compareWithCurveOrder(_ data: Data) -> Int {
        let bytes = [UInt8](data)
        for i in 0..<32 {
            if bytes[i] < curveOrder[i] { return -1 }
            if bytes[i] > curveOrder[i] { return 1 }
        }
        return 0
    }
    
    /// Subtract curve order from data (for modular reduction)
    private static func subtractCurveOrder(from data: Data) -> Data {
        var result = [UInt8](repeating: 0, count: 32)
        var borrow: Int16 = 0
        
        let bytes = [UInt8](data)
        
        for i in (0..<32).reversed() {
            let diff = Int16(bytes[i]) - Int16(curveOrder[i]) - borrow
            if diff < 0 {
                result[i] = UInt8((diff + 256) & 0xFF)
                borrow = 1
            } else {
                result[i] = UInt8(diff & 0xFF)
                borrow = 0
            }
        }
        
        return Data(result)
    }
    
    /// Check if private key is valid for secp256k1
    private static func isValidPrivateKey(_ key: Data) -> Bool {
        guard key.count == 32 else { return false }
        
        // Key must not be zero
        let isZero = key.allSatisfy { $0 == 0 }
        guard !isZero else { return false }
        
        // Key must be less than curve order
        return compareWithCurveOrder(key) < 0
    }
    
    // MARK: - Private Methods - secp256k1 Operations via web3.swift
    
    /// Generate uncompressed secp256k1 public key from private key
    ///
    /// Uses web3.swift's secp256k1 implementation for MetaMask compatibility.
    ///
    /// - Parameter privateKey: 32-byte private key
    /// - Returns: 64-byte uncompressed public key (without 0x04 prefix)
    private static func generateSecp256k1PublicKey(from privateKey: Data) throws -> Data {
        // Use web3.swift to create an Ethereum private key and get its public key
        guard let hexPrivateKey = privateKey.web3.hexString.web3.noHexPrefix as String?,
              let ethPrivateKey = try? EthereumPrivateKey(hexPrivateKey: hexPrivateKey) else {
            throw EthereumKeyError.invalidPrivateKey
        }
        
        // Get the raw public key bytes (uncompressed, 64 bytes without prefix)
        let publicKeyBytes = ethPrivateKey.publicKey.rawBytes
        
        return Data(publicKeyBytes)
    }
    
    /// Generate compressed secp256k1 public key from private key (33 bytes)
    ///
    /// Used for BIP-32 non-hardened derivation.
    ///
    /// - Parameter privateKey: 32-byte private key
    /// - Returns: 33-byte compressed public key
    private static func generateCompressedSecp256k1PublicKey(from privateKey: Data) throws -> Data {
        guard let hexPrivateKey = privateKey.web3.hexString.web3.noHexPrefix as String?,
              let ethPrivateKey = try? EthereumPrivateKey(hexPrivateKey: hexPrivateKey) else {
            throw EthereumKeyError.invalidPrivateKey
        }
        
        // Get the public key bytes and compress them
        // The raw bytes are 64 bytes (x, y coordinates)
        let publicKeyBytes = ethPrivateKey.publicKey.rawBytes
        
        // Ensure we have the expected 64 bytes (x, y coordinates)
        guard publicKeyBytes.count == 64 else {
            throw EthereumKeyError.invalidPublicKey
        }
        
        // Compress: prefix (0x02 or 0x03 based on y parity) + x coordinate
        let xCoord = publicKeyBytes.prefix(32)
        let yCoord = publicKeyBytes.suffix(32)
        guard let lastYByte = yCoord.last else {
            throw EthereumKeyError.invalidPublicKey
        }
        let yIsEven = lastYByte & 1 == 0
        let prefix: UInt8 = yIsEven ? 0x02 : 0x03
        
        var compressed = Data([prefix])
        compressed.append(contentsOf: xCoord)
        
        return compressed
    }
    
    /// Generate Ethereum address from uncompressed public key using Keccak-256
    ///
    /// - Parameter publicKey: 64-byte uncompressed public key (without 0x04 prefix)
    /// - Returns: Checksummed Ethereum address with 0x prefix
    private static func generateAddressFromPublicKey(_ publicKey: Data) throws -> String {
        // Keccak-256 hash of the public key
        let hash = publicKey.web3.keccak256
        
        // Take last 20 bytes of the hash
        let addressBytes = hash.suffix(20)
        
        // Convert to hex string
        let addressHex = addressBytes.map { String(format: "%02x", $0) }.joined()
        
        // Return EIP-55 checksummed address
        return checksumAddress(addressHex)
    }
}
